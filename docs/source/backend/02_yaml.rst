Задача #2: Чтение YAML
======================

Структура
---------

У проекта планируется следующая структура::

    Assets/
        Player/
            [Hobbies|Phobias|Health|Profession|Info|Baggage].yml
        Global/
            [World|Equipment|Rooms].yml
        Actions.yml
        Events.yml
    Bulker.exe

В данной задаче будет рассмотрено чтение всех YAML скриптов проекта - в частности, чтение характеристик игрока (*traits*), условий мира (*conditions*), карт событий (*event cards*) и карт действий (*action cards*).

В C# отсутствует встроенный YAML-десериализатор (т.е. конвертатор из скрипта в объект C#), но можно использовать общедоступную библиотеку **YamlDotNet**.

Это задание, вполне вероятно, станет самым трудоёмким ввиду того, что оно по сути делится на 4 части (хоть и наследующие одну и ту же логику).

0. Вводное задание
------------------

Алгоритм
~~~~~~~~

В записи игрока с предыдущего задания есть следующие свойства:

.. code-block:: csharp

    int age { get; set; };
    Gender gender { get; set; };
    bool isFertile { get; set; };

В данном случае генерацию этих свойств придётся вынести в отдельный метод, а сами свойства *удалить*.

Данные свойства не имеют практического применения в записи. При переносе программы на архитектуру "сервер-клиент" они лишь станут лишней информацией, которая может быть полезна, разве что, возможным спуферам, которые могут таким образом узнать нераскрытую черту.

Генерация отныне будет использоваться для генерации *одной* из характеристик, состоящей из **названия** и **описания**.

Следующее же задание будет реализовать интерфейс для остальных характеристик, так что сразу реализуем один из паттернов для лёгкой циклической их инициализации и содержания:

.. code-block:: csharp

    // Определение

    interface ITrait
    {
        public string Name { get; set; }
        public (string Value, string Tooltip) Extract();
    }

    class BioTrait : ITrait
    {
        public string Name { get; } = "Биологическая характеристика";
        public (string Value, string Tooltip) Extract();
    }

    // Новые поля данных сервиса

    class PlayerService
    {
        // ...
        private Dictionary<string, ITrait> TraitsCollection;
        private Dictionary<Player, Dictionary<string, (string Value, string Tooltip)>> PlayerTraits; // Пример со словарём; для записи в БД придётся отдельно выражать CRUD-операции и инициализировать новую таблицу
    }

    // Отдельная инициализация для биологической характеристики

    TraitsCollection["bio"] = new BioTrait();

    // Пример инициализации игрока

    Player dima = new Player("Dima");
    PlayerTraits[dima]["bio"] = TraitsCollection["bio"].Extract(); // ("♂️ 66 лет", "Не фертилен")

Как может быть отсюда видно, генерация трёх свойств выше по сути переносится в метод ``Extract()`` класса ``BioTrait``. И вместо возвращаемых трёх свойств передаётся кортеж из двух строк: названия и описания.

Название содержит в себе пол и возраст, описание - фертильность.

После реализации интерфейса ``ITrait`` в виде биологической характеристики ``BioTrait`` стоит предоставить фронт-энду интерфейс для извлечения необходимой информации. В данном случае это:

* Чтение доступных характеристик игрока; используется метод ``Dictionary<string, string> GetTraits()`` (ключ здесь кодовое название, значение: выводимое название). На данный момент это будет словарь с единственной записью: ``["bio"]: "Биологическая характеристика"``.
* Передача определённой характеристики конкретного игрока; используется метод ``(string Value, string Tooltip) GetPlayerTrait(Guid, string TraitKey)``.
    #. По ID находится запись в БД/словаре игроков;
    #. Если найдена, запись используется как ключ для ``PlayerTraits``, во вложенном словаре как ключ используется ``TraitKey`` в итоге как пример возвращаем ``PlayerTraits[dima]["bio"] => ("♂️ 66 лет", "Не фертилен")``.

Задание
~~~~~~~

Оставить пользователю доступ только к получению единой биологической характеристики игрока, вместо полного доступа к отдельным свойствам ``age`` и ``gender`` в самой записи.

Крайне желательно при этом заложить почву для последующих характеристик и реализовать одинаковый интерфейс и для "bio", и для остальных.

1. Характеристики игрока
------------------------

Алгоритм
~~~~~~~~

Предположим, у пользователя лежат следующие кастомные черты (и в одном файле):

.. code-block:: yaml

    hobbies:
        name: 'Хобби'
        type: ValueOnly
        traits:
            - 'Психология и тренинги'
            - 'Настольные игры'
            - 'Первая помощь'

    phobias:
        name: 'Фобии'
        type: ValueTooltip
        traits:
            - value: 'Агиофобия'
              tooltip: 'Боязнь священных предметов или священника'
            - value: 'Афобофобия'
              tooltip: 'Cтрах, что у тебя нет никаких фобий'

Здесь представлены два типа записей, которые необходимо реализовать: ``ValueOnly`` и ``ValueTooltip``. Как ни трудно догадаться, в первом типе детальных описаний для каждой строки нет, а во втором есть.

Ниже представлена идея алгоритма:

.. code-block:: csharp

    // Определение

    interface ITrait
    {
        public string Name { get; set; }
        public (string Value, string Tooltip) Extract();
    }

    class TraitValueOnly : ITrait
    {
        public string Name { get; set; }
        public List<string> Traits { get; set; }
        public (string Value, string Tooltip) Extract();
    }

    class TraitValueTooltip : ITrait
    {
        public string Name { get; set; }
        public List<(string Value, string Tooltip)> Traits { get; set; }
        public (string Value, string Tooltip) Extract();
    }

    // Инициализация PlayerService: составляем словарь всех характеристик (который будет полем данных для сервиса). Ключ здесь кодовое имя черты.

    Dictionary<string, ITrait> traits = new Dictionary<string, ITrait>();

    // Тут самое интересное: чтение всех YAML-файлов, добавление всех характеристик...

    // Конечный результат

    traits = {
        ["hobbies"] = {
            Name = "Хобби",
            Traits = {
                "Психология и тренинги",
                "Настольные игры",
                "Первая помощь"
            }
        },
        ["phobias"] = {
            Name = "Фобии",
            Traits = {
                ("Агиофобия", "Боязнь священных предметов или священника"),
                ("Афобофобия", "Страх, что у тебя нет никаких фобий")
            }
        }
    };

    // Новые поля данных сервиса

    class PlayerService
    {
        // ...
        private Dictionary<string, ITrait> TraitsCollection;
        private Dictionary<Player, Dictionary<string, (string Value, string Tooltip)>> PlayerTraits; // Пример со словарём; для записи в БД придётся отдельно выражать CRUD-операции и инициализировать новую таблицу
    }

    // Пример инициализации игрока

    Player dima = new Player("Dima");
    PlayerTraits[dima]["hobbies"] = TraitsCollection["hobbies"].Extract(); // ("Настольные игры", "")
    PlayerTraits[dima]["phobias"] = TraitsCollection["phobias"].Extract(); // ("Агиофобия", "Боязнь священных предметов или священника")

Вкратце, логика такова:

#. ``PlayerService`` при своей инициализации читает все YAML скрипты, находящиеся по директории `./Assets/Player/` *(и глубже)*.
#. Выходит хэш-таблица из всех пользовательских характеристик.
#. Для игрока генерируется отдельная запись в словаре/таблице БД, где инициализируются все его характеристики. Перебираются все пары "ключ/значение" в словаре TraitsCollection в цикле.

.. note::
    К сожалению, с данными YAML скриптами придётся реализовать более сложное *потоковое чтение*. Кроме него, у библиотеки есть встроенный *объектный десериализатор*, который можно использовать в менее комплексных случаях.

* Для чтения доступных кастомных характеристик игрока используется метод ``Dictionary<string, string> GetTraits()`` (ключ здесь кодовое название, значение: выводимое название).
* Для передачи определённой характеристики конкретного игрока используется метод ``(string Value, string Tooltip) GetPlayerTrait(Guid, string TraitKey)``.
* Для обновления характеристики игрока используется метод ``void RandomizePlayerTrait(Guid, string TraitKey)``.
* Для обмена характеристиками игроков используется метод ``void SwapPlayerTrait(Guid subject, Guid object, string TraitKey)``.

Задание
~~~~~~~

#. Реализовать потоковое чтение YAML скрипта. В качестве базы можно использовать пример выше.
    * Топовый уровень всегда кодовое название, которое выступает ключом в словаре ``traits``.
    * Обязательным полем является ``name``, выступающее как удобноваримое название.
    * По ``type`` определяется, какая форма записи перед нами.
        * Если это ``ValueOnly``, инициализируем объект ``TraitValueOnly`` и читаем в ``traits`` массив строк (``YamlScalarNode``).
        * Если это ``ValueTooltip``, инициализируем объект ``TraitValueTooltip`` и читаем в ``traits`` массив объектов "значение/описание" (``YamlMappingNode``).
    * При ошибке чтение текущей записи прерывается. Запись в словарь не производится, но продолжается чтение файлов на другие черты.
#. Предоставить для фронт-энда вышеописанные интерфейсы.
#. Реализовать *рекурсивное* чтение файлов `.yml` / `.yaml` по директории `./Assets/Player/`.
    * Папку `assets` можно держать в корневой папке проекта. При компиляции же копировать её в папку с бинарником.

2. Условия мира
---------------

TBD

3. Карты событий
----------------

TBD

4. Карты действий
-----------------

TBD

Материалы для изучения
----------------------

* `Страница репозитория YamlDotNet <https://github.com/aaubry/YamlDotNet>`_
* `YamlDotNet Wiki: Потоковое чтение YAML <https://github.com/aaubry/YamlDotNet/wiki/Samples.LoadingAYamlStream>`_