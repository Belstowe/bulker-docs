Задача #2: Макет игры. Махинации с игроками 
===========================================

После первого разогревочного задания идёт, конечно, самая сложная основная часть.

В данной задаче вами будет определён облик самой главной страницы, где будет протекать игра.

Макет главной страницы
----------------------

Следующий план я нарисовал в редакторе, так что HTML-скрипта под него у меня нет (но повторить его, думаю, не составит труда):

.. image:: img/02_layout.png

Можно отметить 3 панели: самая большая панель с игроками (занимает 80%/80% пространства), нижняя панель ведущего (80%/20%) и боковая панель условий (20%/100%).

В общем и целом такой интерфейс подобен тому, что был в оригинальном Булкере, но теперь он растягивается практически на весь экран (самые края (~5%) я бы всё же не задействовал, заштриховал и выделил бы полезную часть тенью).

Контейнер игрока
----------------

Несмотря на предыдущее заявление, что вряд ли лучше таблицы я что-нибудь придумаю, всё же что-нибудь более-менее приятное на глаз придумать хотелось *(ибо таблица, честно, смотрится не очень)*.

Так что вместо *"каждому по столбцу в таблице"* предлагаю сделать *"каждому по контейнеру"*.

Такой подход даёт большой простор для фантазий, а соответственно для будущего дизайна; позволяет сам дизайн сделать более привлекательным; переделать затем контейнеры в таблицу легче, чем таблицу в набор контейнеров.

В качестве прототипа можно использовать следующий дизайн:

.. figure:: img/02_player_box_dead.png
    :width: 240 px
    :align: right

    Вид мёртвого игрока

.. figure:: img/02_player_box.png
    :width: 240 px
    :align: left

    Вид с раскрытыми хар-ками

.. figure:: img/02_player_box_crossed.png
    :width: 240 px
    :align: center

    Вид с нераскрытыми хар-ками

.. note::
    Используемый здесь шрифт: **Bahnschrift**.

С прототипом вы вольны делать что угодно. Сейчас я бы не сказал, к сожалению, что он хорошо помещается в экран игры. Его пропорции не позволяют ни разместить шаблон в 2 ряда, ни проставить достаточно в 1 ряд.

Так что можете либо *сократить высоту*, вместив `заголовок/значение` в один ряд или как-то объединив шапку с именем, либо *сократить ширину*, используя везде сжатые шрифты и одинаковое выравнивание.

Активный игрок (чей ход сейчас идёт) помечается светлой обводкой.

При наведении на поле характеристики строка выделяется: например, шрифт становится жирнее либо меняет цвет. При скрытой характеристики штриховка становится светлей.

На убитых/выгнанных игроках использован чёрно-белый фильтр, их фон темней, а возле их имени стоит крест. Можете использовать какие-то другие способы помечать, что игрок мёртв.

Дополнительные характеристики (всё, кроме биологической) определяются при инициализации сервером и передаются им через интерфейс ``Dictionary<string, string> IPlayerService.GetTraits()``. Здесь ключ - кодовое название, которое может передаваться как id черты, а значение - выводимое название.

Кроме того, в интерфейсе ``IEnumerable<Player> IPlayerService.GetPlayers()`` сервер передаёт в модели игрока следующие характеристики:

.. code-block:: csharp

    enum Gender { Male, Female };

    record Player {
        Guid id;
        DateTimeOffset dateCreated;
        Color color;
        String name;
        bool isAlive;
        int age;
        Gender gender;
        bool isFertile;
    }

.. note::
    Стоит отдельно объяснить несколько вещей:

    * У игроков есть цветные шапки. У каждого игрока свой уникальный цвет, который генерируется сервером. Такой дизайн необходим для этапа голосования.
    * Характеристики с подробным описанием помечены пунктиром (описание выводится при наведении мышкой). Если у характеристики нет описания, в ``Tooltip`` передаётся пустая строка. 
    * Возраст (кстати, обозначенный Unicode-символом) и пол игрока объединены, и раскрываются вместе (а в описании выводится фертильность).

События
-------

Выше было описано наведение на поле характеристики, которое подразумевает, что с ним можно взаимодействовать.

Кроме того, что характеристику можно *раскрыть*, ей можно *обменяться* либо *рандомизировать* (когда игрок обыгрывает , например).

Предлагаю следующие действия:

* Чтобы **раскрыть характеристику**, мышка зажимается на заштрихованной черте. Штриховка в это время, например, постепенно переходит в цвет фона. Используется метод ``(string Value, string Tooltip) IPlayerService.GetPlayerTrait(Guid, string TraitKey)``.
* Чтобы **обменять характеристики двух игроков**, мышка нажимается на черте одного игрока и отпускается на нужном игроке. Используется метод ``void IPlayerService.SwapPlayerTrait(Guid subject, Guid object, string TraitKey)``.
* Чтобы **сгенерировать новую черту**, на правой кнопке мыши вызывается контекстное меню с необходимым действием. Используется метод ``void IPlayerService.RandomizePlayerTrait(Guid, string TraitKey)``.

Панель условий
--------------

TBD

Экспорт
-------

TBD

Таймер
------

Таймером можно заняться, пока команда backend медлит.

Каких-то особых рекомендаций по таймеру у меня нет: единственное, рекомендую сделать ввод времени напрямую в таймер, а заморозку сделать просто отсчётом времени вперёд.

Задание
-------

#. Сделать переход с меню инициализации на новую страницу.
#. Сверстать в общих чертах главную страницу.
#. Сделать контейнер с информацией про игрока (можно пока только с основной информацией); определить, каким образом раскладывать в игре контейнеры; *протестировать с шаблонными именами, если backend так и не завершил свою работу*.
#. Добавить раскрытие характеристик; запустить циклически раунд с раскрытием характеристик.
#. Обеспечить нормальную работу с дополнительными характеристиками. *Требуется взаимодействие с backend.*
#. Написать события раскрытия, обмена и рандомизации черты. *Требуется взаимодействие с backend.*
#. Написать модуль таймера.